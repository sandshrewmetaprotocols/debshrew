//! Transform trait and related types for debshrew
//!
//! This module defines the transform trait and related types for debshrew,
//! which are used to implement transform modules that convert metaprotocol state
//! into CDC streams.

use crate::error::Result;
use debshrew_support::{CdcMessage, TransformState};
use std::fmt::Debug;

/// Transform trait
///
/// This trait defines the interface for transform modules, which convert
/// metaprotocol state into CDC streams.
pub trait DebTransform: Default + Debug + Clone {
    /// Process a block and generate CDC messages
    ///
    /// This method is called for each new block. It should query metashrew views
    /// to get metaprotocol state, compare with previous state to detect changes,
    /// generate CDC messages for the changes, and update internal state.
    ///
    /// # Returns
    ///
    /// A vector of CDC messages if processing was successful
    ///
    /// # Errors
    ///
    /// Returns an error if processing fails
    fn process_block(&mut self) -> Result<Vec<CdcMessage>>;

    /// Generate inverse CDC messages for rollback
    ///
    /// This method is called during chain reorganizations. It should generate
    /// inverse CDC messages that undo the changes from the rolled-back blocks.
    ///
    /// The default implementation returns an empty vector, as the runtime can
    /// automatically generate inverse CDC messages based on the original messages.
    ///
    /// # Returns
    ///
    /// A vector of CDC messages for the rollback if successful
    ///
    /// # Errors
    ///
    /// Returns an error if rollback fails
    fn rollback(&mut self) -> Result<Vec<CdcMessage>> {
        // Default implementation returns an empty vector
        // The runtime can automatically generate inverse CDC messages
        Ok(Vec::new())
    }
}

/// Transform module result
///
/// This struct represents the result of a transform module operation,
/// including the CDC messages generated and a snapshot of the state.
#[derive(Debug, Clone)]
pub struct TransformResult {
    /// CDC messages generated by the transform module
    pub cdc_messages: Vec<CdcMessage>,
    
    /// Snapshot of the transform state after the operation
    pub state_snapshot: TransformState,
}

impl TransformResult {
    /// Create a new transform result
    ///
    /// # Arguments
    ///
    /// * `cdc_messages` - The CDC messages generated by the transform module
    /// * `state_snapshot` - A snapshot of the transform state after the operation
    ///
    /// # Returns
    ///
    /// A new transform result
    pub fn new(cdc_messages: Vec<CdcMessage>, state_snapshot: TransformState) -> Self {
        Self {
            cdc_messages,
            state_snapshot,
        }
    }
}

/// Mock transform for testing
///
/// This struct implements the `DebTransform` trait for testing purposes.
#[derive(Debug, Default, Clone)]
pub struct MockTransform {
    /// The transform state
    pub state: TransformState,
    
    /// The CDC messages to return from process_block
    pub process_block_messages: Vec<CdcMessage>,
    
    /// The CDC messages to return from rollback
    pub rollback_messages: Vec<CdcMessage>,
}

impl DebTransform for MockTransform {
    fn process_block(&mut self) -> Result<Vec<CdcMessage>> {
        Ok(self.process_block_messages.clone())
    }
    
    fn rollback(&mut self) -> Result<Vec<CdcMessage>> {
        Ok(self.rollback_messages.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use debshrew_support::{CdcHeader, CdcOperation, CdcPayload};
    use std::time::{SystemTime, UNIX_EPOCH};

    #[test]
    fn test_transform_result() {
        let messages = vec![CdcMessage {
            header: CdcHeader {
                source: "test".to_string(),
                timestamp: SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u64,
                block_height: 123,
                block_hash: "000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d".to_string(),
                transaction_id: None,
            },
            payload: CdcPayload {
                operation: CdcOperation::Create,
                table: "test_table".to_string(),
                key: "test_key".to_string(),
                before: None,
                after: Some(serde_json::json!({
                    "field1": "value1",
                    "field2": 42
                })),
            },
        }];

        let state = TransformState::new();
        let result = TransformResult::new(messages.clone(), state);

        assert_eq!(result.cdc_messages.len(), 1);
        assert_eq!(result.cdc_messages[0].payload.table, "test_table");
    }
}