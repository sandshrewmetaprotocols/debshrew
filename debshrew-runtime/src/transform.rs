//! Transform trait and related types for debshrew
//!
//! This module defines the transform trait and related types for debshrew,
//! which are used to implement transform modules that convert metaprotocol state
//! into CDC streams.

use crate::error::Result;
use debshrew_support::{CdcMessage, TransformState};
use std::fmt::Debug;

/// Transform trait
///
/// This trait defines the interface for transform modules, which convert
/// metaprotocol state into CDC streams.
pub trait DebTransform: Default + Debug {
    /// Process a block and generate CDC messages
    ///
    /// This method is called for each new block. It should query metashrew views
    /// to get metaprotocol state, compare with previous state to detect changes,
    /// generate CDC messages for the changes, and update internal state.
    ///
    /// # Returns
    ///
    /// A vector of CDC messages generated for the block
    ///
    /// # Errors
    ///
    /// Returns an error if processing fails
    fn process_block(&mut self) -> Result<Vec<CdcMessage>>;

    /// Generate inverse CDC messages for rollback
    ///
    /// This method is called during chain reorganizations. It should generate
    /// inverse CDC messages that undo the changes from the rolled-back blocks.
    ///
    /// # Returns
    ///
    /// A vector of inverse CDC messages for rollback
    ///
    /// # Errors
    ///
    /// Returns an error if rollback fails
    fn rollback(&mut self) -> Result<Vec<CdcMessage>>;
}

/// Transform module result
///
/// This struct represents the result of a transform module operation,
/// including the CDC messages generated and a snapshot of the state.
#[derive(Debug, Clone)]
pub struct TransformResult {
    /// CDC messages generated by the transform module
    pub cdc_messages: Vec<CdcMessage>,
    
    /// Snapshot of the transform state after the operation
    pub state_snapshot: TransformState,
}

impl TransformResult {
    /// Create a new transform result
    ///
    /// # Arguments
    ///
    /// * `cdc_messages` - The CDC messages generated by the transform module
    /// * `state_snapshot` - A snapshot of the transform state after the operation
    ///
    /// # Returns
    ///
    /// A new transform result
    pub fn new(cdc_messages: Vec<CdcMessage>, state_snapshot: TransformState) -> Self {
        Self {
            cdc_messages,
            state_snapshot,
        }
    }
}

/// Transform module factory
///
/// This trait defines a factory for creating transform modules.
pub trait TransformFactory {
    /// The type of transform module created by this factory
    type Transform: DebTransform;

    /// Create a new transform module
    ///
    /// # Returns
    ///
    /// A new transform module
    fn create(&self) -> Self::Transform;
}

/// Default transform factory
///
/// This struct implements the `TransformFactory` trait for a transform module
/// that implements `Default`.
#[derive(Debug, Clone, Copy)]
pub struct DefaultTransformFactory<T: DebTransform>(std::marker::PhantomData<T>);

impl<T: DebTransform> DefaultTransformFactory<T> {
    /// Create a new default transform factory
    ///
    /// # Returns
    ///
    /// A new default transform factory
    pub fn new() -> Self {
        Self(std::marker::PhantomData)
    }
}

impl<T: DebTransform> Default for DefaultTransformFactory<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: DebTransform> TransformFactory for DefaultTransformFactory<T> {
    type Transform = T;

    fn create(&self) -> Self::Transform {
        T::default()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use debshrew_support::{CdcHeader, CdcOperation, CdcPayload};
    use chrono::Utc;

    #[derive(Debug, Default)]
    struct TestTransform {
        #[allow(dead_code)]
        state: TransformState,
    }

    impl DebTransform for TestTransform {
        fn process_block(&mut self) -> Result<Vec<CdcMessage>> {
            let message = CdcMessage {
                header: CdcHeader {
                    source: "test".to_string(),
                    timestamp: Utc::now(),
                    block_height: 123,
                    block_hash: "000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d".to_string(),
                    transaction_id: None,
                },
                payload: CdcPayload {
                    operation: CdcOperation::Create,
                    table: "test_table".to_string(),
                    key: "test_key".to_string(),
                    before: None,
                    after: Some(serde_json::json!({
                        "field1": "value1",
                        "field2": 42
                    })),
                },
            };

            Ok(vec![message])
        }

        fn rollback(&mut self) -> Result<Vec<CdcMessage>> {
            let message = CdcMessage {
                header: CdcHeader {
                    source: "test".to_string(),
                    timestamp: Utc::now(),
                    block_height: 122,
                    block_hash: "000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d".to_string(),
                    transaction_id: None,
                },
                payload: CdcPayload {
                    operation: CdcOperation::Delete,
                    table: "test_table".to_string(),
                    key: "test_key".to_string(),
                    before: Some(serde_json::json!({
                        "field1": "value1",
                        "field2": 42
                    })),
                    after: None,
                },
            };

            Ok(vec![message])
        }
    }

    #[test]
    fn test_transform_result() {
        let messages = vec![CdcMessage {
            header: CdcHeader {
                source: "test".to_string(),
                timestamp: Utc::now(),
                block_height: 123,
                block_hash: "000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d".to_string(),
                transaction_id: None,
            },
            payload: CdcPayload {
                operation: CdcOperation::Create,
                table: "test_table".to_string(),
                key: "test_key".to_string(),
                before: None,
                after: Some(serde_json::json!({
                    "field1": "value1",
                    "field2": 42
                })),
            },
        }];

        let state = TransformState::new();
        let result = TransformResult::new(messages.clone(), state);

        assert_eq!(result.cdc_messages.len(), 1);
        assert_eq!(result.cdc_messages[0].payload.table, "test_table");
    }

    #[test]
    fn test_default_transform_factory() {
        let factory = DefaultTransformFactory::<TestTransform>::new();
        let mut transform = factory.create();

        let messages = transform.process_block().unwrap();
        assert_eq!(messages.len(), 1);
        assert_eq!(messages[0].payload.table, "test_table");
    }
}